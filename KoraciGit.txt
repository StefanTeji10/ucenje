GitHub: Getting Started
https://tkrajina.github.io/uvod-u-git/git.pdf

Osnovni pojmovi:
	commit
	push
	fetch
	conflict
	origin repository
	
	
	
	
Komande
	git init 	--> inicijalizuje prazan Git repozitorijum u folderu u kom se trenutno nalazimo
				--> stvoren je folder .git
	
	git help <naredba>
	
	git config <naredba>	--> Sva git konfiguracija se postavlja pomocu ove naredbe
	git config --global <naziv> <vrednost>  --> Globalne konfiguracije one se postavljaju u fajl .gitconfig u home direktorijumu na nasoj lokalnoj masini
	
	git config <naziv> <vrednost> --> Postavlja lokalne postavke koje se stavljaju u .git direktorijum koji se nalazi u direktorijumu koji smo inicijalizovali sa git init
	
	git config --global color.ui auto --> Ispis git naredbi da bude obojen
	git config --global color.ui always
	
	
	git config --global merge.tool gvimdiff --> jedna od opcija koja odredjuje kako ce se program koristiti u slucaju kada se dogode konflikti (napredno)
	
	
	
.gitignore
	Ukoliko postoje fajlovi koje ne zelimo da ukljucimo na git. Ovaj folder mi kreiramo u glavnom projektu (ne nekom od podirektorijuma), i jednostavno unesemo sta ne zelimo da bude deo projekta
	
	

Spremanje izmena (commit)


	U Gitu nikada ne commitamo u udaljeni repozitorijum. Svoje lokalne promene komitujemo, u lokalni repozitorijum na nasem racunaru. Interakcija sa udaljenim repozitorijumom je nesto drugo. 
	
	Status
		>>git status --> salje nam da li postoje fajlovi koji na sebi imaju izmene i izlistava koje su promene
		
		>>git diff 	--> daje nam koje su tacne razlike izmedju fajlova
					--> git ne zna da smo neku liniji izmenili, on staru prikazuje kao da smo je obrisali, i napravili novu
		
		>>git diff -U10 --> prikazuje 10 linija koda ili teksta u okolini izmene, a ne samo tu izmenjenju liniju kao u slucaju sa samo diff
		
	Indeks
		Postoje tri razlicita "mesta" u kojima se cuvaju fajlovi, odnosno konkretna stanja pojedinih fajlova:
			1) Git repozitorijum 			--> cuva razlicita stanja izmenjenog fajla
			2) Radana verzija repozitorijuma 	--> je stanje fajlova u nasem folderu. OVo moze biti isto ili razlicito u odnosu na stanje fajloba u repozitorijumu. 
			3) Poseban "medjuprostor" za commit --> privremeno stavljamo trenutno stanje fajlova pre nego sto ih komitujemo. 
			
			Ovo zadnje stanje, odnosto taj medjuprostor se zove index. (staging area ili cache)
		git	
			>>git add <imeFajla>  --> daje nam status promena "Changes to be committed", umesto pre add komande (Changes not staged for commit)
			
			
		Uklanjanje iz indeksa
		
			>>git reset HEAD -- <fajl1> <fajl2>... 	--> izbacuje fajl iz indeksa
			
			>>git checkout HEAD -- <fajl1> <fajl2>...	--> ukoliko zelimo da vratimo stanje kakvo je u repozitorijumu, znaci da uklonimo izmene za koje smo se predomislili da comitujemo
			
	Prvi commit
		git commit -m "Nova verzija" 	--> "Nova verzija" je komentar koji je neophodan za svaku izmenu, ovo comituje fajl u nas lokalni repozitorijum
	

	Dadoteke (fajlovi) koje ne zelimo u repozitorijumu
		Prvo trebamo tu dadoteku koju zelimo da uklonimo da dodamo u .gitignore fajl. Njene promene nece uticati na git od tada ali ce i dalje biti u repozitorijumu. 
		
		git rm --cached <imefajla> --> dodaje u index ali sa stanjem za brisanje, sada tu izmenu treba commit da bi git znao da od ovog momenta pa na dalje ovaj fajl moze obrisati. 


 	
	Istorija projekta
		git log --> da vidimo sve prethodne commitove
			--> Napomena: Svaki commit ima svoj jedinstveni string
		
	
	Ispravljanje zadnjeg commit-a
		>>git add <fajl> --> dodamo u index fajl koji treba spojiti sa prethodnim commit-om
		
		>>git commit --amend -m "Nova verzija, promenjen <fajl>"

		Naredba --amend govori gitu da izmeni prethodni komit
		
	Git gui
		>>git gui 	--> Gitgui je graficki prikaz gita, koji omogucava odredjene lagodnosti. 		
				--> Veoma mocna stvar koja se treba dodatno izuciti

	
	Clean
		git clean 	--> Brise dadoteke iz repozitorijuma			
		git clean -n	--> Lista dadoteka koje ce biti obrisane sa naredbom git clean
		git clean -x 	--> Brise sve dadoteke dodate u .gitignore
		
		git clean -f	--> brise sve direktorijume prikazane sa git clean -n
		git celan -f -- <direktorijum> samo odredjene dadoteke ili samo jedan direktorijum


Grananje
		Svaki cvor grafa je stanje projekta u nekom trenutku u njegovoj istoriji.
	
	Potpis grana projekta
		>>git branch 	--> da vidimo grane naseg projekta
				--> svaki git projekat u pocetku ima samo jednu granu i ona se uvek zove master.
				--> !!! Grana u kojoj se nalazimo imace zvezdicu na pocetku

	Nova grana
		>>git branch <imeGrane> --> ovako pravimo novu granu sa imenom <imeGrane>
	

	Prebacivanje sa grane na granu
		>>git checkout <imeGrane> 	--> prebacivanje sa grane na granu, moze i sa vise u nizu u hijerarhiji i obrnuto ime grane moze da nam bude npr. master da bi se vratili u master granu
						--> u novoj grani vec imamo pristup fajlovim iz master grane

			--> Ukoliko imamo nekih izmena koje nismo commit-ovali moguce je da nam git nece dozvoliti prebacivanje
			--> Najbolje je prebacivati se nakon sto smo uradili commit za sve izmene

	Brisanje grane
		>>git branch -D <imeGrane> 	--> Brise granu pod imenom <imeGrane>
						--> Ne mozemo obrisati master granu!

				--> Ne mozemo obrisati granu na kojoj se trenutno nalazimo	
				--> Brisanjem grane ne brisemo njene ranije commit-ove, oni ostaju deo istorije. 

	Preuzimanje dadoteka iz druge grane
		>>git checkout <nazivGrane> -- <datoteka1> <datoteka2> ...
		

Preuzimanje izmena iz jedne u drugu granu
	Preuzimanje izmena iz jedne grane u drugu naziva se merge!
	Nakon merge-a dve grane nastavljaju svoje zivote, ne spajaju se u potpunosti. Samo se sve izmene u jednoj grani preuzimaju u drugu. 


	Git merge
		>> git merge <branchName> 	--> radimo iz grane u koju zelimo da merge-ujemo
						--> ukoliko nema konflikata dobio poruku o odradjenom i automatski spajamo izmene, 
						--> ukoliko ima konflikata treba da ih resimo
						--> ukoliko merge prodje on automatski radi commit
						--> Za razliku od prethodnih commit-a ovaj ima dava "roditelja", "prethodnika". 
	

		Resavanje konflikta
			--> Autor edituje i izmeni kako zeli. Nakon toga je treba commit-ovati.
			--> Drugi nacin je koristeci git mergetool. 
			
			>>git config --global merge.tool </putanja/do/programa>		--> C:\ProgramData\Microsoft\Windows\Start Menu\Programs
				--> meld -- jedan od programa
				--> DiffMerge -- drugi program

			>>git difftool 			--> pusta u rad prekonfigurisani editor za razlike u fajlu .gitconfig
			>>git difftool -t <imePrograma>	--> pusta program vimdiff
			>>git difftool <branch1>/<branch2>	--> origin/master (local host(github)/master branch)
	
			!!!Ako nakon neuspelog merge otvorimo fajl u njemu je dodato gde je konflikt
					

	Merge, branch i istorija projekta
		
		Fast forward
			git merge --no-ff <varijanta> 	--> git automatski po potrebi radi fast-forward, a na ovaj nacin ga mozemo zaobici

	Rebase
		>>git rebase master 	--> sluzi da napravimo linearnu putanju vise grana
					--> potrebno je da budemo u grani koju zelimo pomeriti tako da njeni commit-ovi budu u linearnoj ravni sa granom <master> u ovom slucaju. 
					-->  

		>>git rebase --continue --> nastavak nakon resavanja konflikata
		
		>>git rebase --abort	--> odustanak od rebase komande ukoliko ima previse konflikata


	Rebase ili ne rebase?	
		Rebase na kraju krajeva ipak menja istoriju projekta. 


	Cherry-pick
		Posebna verzija merge
		
		>>git cherry-pick <commitString> --> merguje samo odredjeni commit, a ne celu granu i sve njene commitove

	Merge bez commita
		>>git merge <imeGrane> --no-commit 	--> odradjujemo merge ali ne i commit, sada mozemo sami commitati na nacin kako zelimo

		>>git merge <imeGrane> --no-ff --no-commit 	--> jos bolje posto nema opcije da se tokom merge odradi fast-forward

	Squash merge
		git merge --squash <imeGrane> 	--> Ukoliko zelimo da novi cvor ima izmene iz grane, ali ne zelimo da ima referencu na tu granu. 




Tagovi
	>>git tag			--> ispisace definicije prethodno definisanih tagova
	>>git tag <naziv_taga>		--> dodavanje novog taga
	>>git tag -d <naziv_taga>	--> brisanje postojeceg taga


	>>git checkout <broj.broj>	--> primer 1.0 verzija
	Ukoliko zelimo da projekat vratimo na staro stanje na verziju 1.0 na primer, tacnije kada smo definisali tag <1.0> potrebna je ova komanda iznad.
	Nakon te komande tu se moze stvoriti nova grana ili vratiti projekat u zadnje stanje sa komandom:
	>>git checkout HEAD




ISPOD HAUBE
	SHA1
		Jednosmerne matematicke funkcije. Lako je dobiti rezultat, a tesko zakljuciti kako je rezultat nastao. !Hash funkcije!
		SHA1 je string koji ima svaki commit
	SHA1 ima sledeca svojstva:
		Nije jedinstven. 
		Nemoguce je izracunati string iz kog je nastao.

Git nije nista drugo nego graf SHA1 stringova, od kojih svaki jedinstveno identifikuje neko stanje projekta i izracunati su iz tog stanja. 
Osim SHA1 git uz svaki komit cuva i neke metapodatke kao na primer:
	Datum i vreme nastanka
	Komentar
	SHA1 commit-a koji mu je prethodio
	SHA1 commit-a iz kojeg su preuzete izmene za merge (samo ako je rezultat merge-a)
	...

SHA1 nije u potpunosti bezbedan zato se razmatra prelaz na SHA-256


	Grane



UDALJENI REPOZITORIJ (str 96)

	
	Naziv i adresa repozitorijuma
		Prvo sto treba da uradimo je kloniranje nekog udaljenog repozitorijuma. 
		Svaki udaljeni repozitorijum sa kojim zelimo komunicirati mora imati svoju adresu. 
		Svaki udaljeni repozitorijum sa kojim cemo imati posla mora imati i svoje kratko ime (alias).
		(Alias) je uglavno nesto poput <origin>.

	Kloniranje repozitorijuma
		Kloniranje je postupak kojim kopiramo ceo repozitorijum sa udaljene lokacije na nas lokalni racunar. 
		Sa tako kloniranim repozitorijumom mozemo nastaviti rad kao sa repozitorijumom kojeg smo inicirali lokalno. 

		Kopirati repozitorijum je jednostavno. Sve sto je potrebno uraditi je kopirati folder .git. 
		A zatim na ovoj novoj kopiranoj lokaciji izvrsiti 
		>>git checkout HEAD

		Kloniranje je kopiranje udaljenog repozitorijuma, ali tako da novi (lokalni) repozitorijum ostaje "svestan" da je on kopija nekog udaljenog repozitorijuma. 
	
		

 
	